# Matrices et réseaux

```{r}
#| label: loading_packages
#| message: false
#| warning: false
#| echo: false
library(igraph)
library(visNetwork)
library(ggplot2)
library(tidyr)
```

## Taille de la matrice carrée : n = 10

::: {.callout-note collapse="false"}

Attention les graphes considérés sont des graphes orientés ("directed graphs") et donc chaque valeur 1 de la matrice $A$ correspond à un arc (ou arête orientée).
Alors que pour des graphes non orientés nous retrouvons $2n$ valeurs $1$ à l'intérieur de la matrice $A$, qui correspondront à $n$ arêtes (et non pas des arcs si l'on considère la terminologie officielle)
:::
 
```{r}
n <- 10

matrice <- function(n) {
  set.seed(1967)
  v <- sample(c(0,1), size = n^2, replace = TRUE)
  M <- matrix(v, nrow = n, ncol = n)
  # delete edges from node to itself
  for (i in 1:n) {
    M[i, i] <- 0
  }
  return(M)
}

A <- matrice(n)
A
G <- graph_from_adjacency_matrix(A)
data <- toVisNetworkData(G)

```




```{r}
data$nodes$label <- paste(data$nodes$label)
data$nodes$shape <- "circle"
data$edges$arrows <- "to"

head(data$nodes)
head(data$edges)

visNetwork(nodes = data$nodes, edges = data$edges) |> 
  visNodes(color = list(hover = list(background = "yellow", border = "red"))) |>
  visEdges(color = list(highlight = "pink",hover = "red")) |> 
  visInteraction(hover = TRUE)

```

## Large graph analysis

1. Calcul des degrés de chaque noeud :

  - calculé manuellement à partir de la matrice d'adjacence $A$
  
  
  $$out.degree_i=\sum_{j=1}^n A[i,\ j]$$
  
  $$in.degree_i=\sum_{j=1}^n A[j,\ i]$$


```{r}
#| label: degree_from_A
#| 
out.degree <- 1:n |> sapply(\(x) {sum(A[x, ])}) 
in.degree <- 1:n |>  sapply(\(x) {sum(A[, x])})
all.degree <- out.degree + in.degree

out.degree
in.degree
all.degree

```

  - calculé à partir du graph $G$ avec la fonction`degree` du package ìgraph`
  
```{r}
#| label: degree_igraph
#| 
degree_out <- degree(G, v = V(G), mode = c("out"))
degree_in <- degree(G, v = V(G), mode = c("in"))
degree_all <- degree(G, v = V(G), mode = c("all"))

degree_out
degree_in
degree_all

```

  - affichage des degrés par noeud

```{r}

df_degree_per_node <- data.frame(
  node = 1:length(V(G)), 
  degree_all = degree_all,
  degree_in = degree_in,
  degree_out = degree_out
) |> 
  pivot_longer(
    cols = c(degree_all, degree_in, degree_out), 
    names_prefix = "degre_",
    names_to = "degree_type", 
    values_to = "value"
  )

head(df_degree_per_node)

df_degree_per_node %>%
  ggplot() +
  geom_point(aes(
    x = node, 
    y = value, 
    shape = degree_type, 
    color = degree_type),
    size = 4,
    alpha = 0.6
  ) +
  labs(x = "noeud", y = "degré") +
  scale_x_continuous(breaks = 1:n) +
  scale_y_continuous(
    breaks = \(x) {seq(0, max(x))},
    limits = \(x) {c(0, max(x))}) +
  theme(
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(
      color = "grey90",
      linewidth = 0.5,
      linetype = 1),
    panel.background = element_blank(),
    legend.position = "right"
  ) +
  labs(
    title = "degree per node",
    
  )

df_degree_per_node |> 
  dplyr::filter(degree_type != "all") |> 
  ggplot(aes(x = node, y = value, fill = degree_type)) +
  geom_col() +
  scale_x_continuous(breaks = 1:n) +
  scale_y_continuous(
    breaks = \(x) {seq(0, max(x), 2)},
    limits = \(x) {c(0, max(x))}) +
  theme(
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(
      color = "grey90",
      linewidth = 0.5,
      linetype = 1),
    panel.grid.minor.y = element_line(
      color = "grey60",
      linewidth = 0.5,
      linetype = 3),
    panel.background = element_blank(),
    legend.position = "right"
  ) +
  labs(
    title = "degree per node",
  )
  

```

2. Calcul **Degree Distribution**

The degree distribution of a given degree $k$ in a graph $G$ is the ratio of the number of vertices with degree $k$ to the total number of vertices

$$P(k) = \frac{n_k}{n}$$ avec $n_k$ = number of vertices with degree $k$

  - calculé manuellement à partir de la matrice d'adjacence $A$

```{r}
degree.distrib <- proportions(table(all.degree))
degree.distrib

```

  - calculé à partir du graph $G$ avec la fonction`degree_distribution` du package `igraph`

```{r}

degree_distrib <- degree_distribution(G)
df_degree_distrib <- data.frame(degree = 0:max(degree_all), percent = degree_distrib * 100)
head(df_degree_distrib)

df_degree_distrib |> 
  ggplot(aes(x = degree, y = percent)) +
  scale_x_continuous(breaks = \(x) {seq(0, max(x))}) +
  scale_y_continuous(breaks = \(x) {seq(0, max(x), 10)}) +
  geom_pointrange(aes(ymin = 0, ymax = percent), color = "red") +
  labs(x = "degré", y = "%") +
  theme(
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(
      color = "grey60",
      linewidth = 0.1,
      linetype = 3),
    panel.background = element_blank()
  ) +
  labs(
    title = "degree distribution"
  )
```

3. Calcul **Density**

La mesure de densité d'un graphe donne une idée générale de la structure du graphe.

> If we find that a graph is not dense, we may use data structures for sparse graphs ("graphe creux" in French) for more efficient computations than done by dense graph structures such as adjacency or incidence matrices.

La densité d'un graphe $G$ notée $\rho(G)$ est le ratio du nombre $m$ de ses arêtes rapporté au nombre maximum d'arêtes possibles $n_{max}$ pour ce graphe

$$\rho(G)=\frac{m}{n_{max}},\ avec\ n_{max}=\frac{n(n-1)}{2}$$
$n$ représente ici le nombre de sommets ou noeuds du graphe.

$$soit\ \rho(G)=\frac{2m}{n(n-1)}$$ 

Si l'on considère un graphe orienté et que $m$ représente le nombre d'arcs (arête orientée), le nombre d'arcs maximal devient $n_{max}=n(n-1)$ et $\rho(G)=\frac{m}{n(n-1)}$

  - calculé manuellement à partir de la matrice d'adjacence $A$
  
```{r}
density_A <- sum(A)/(n * (n - 1)) 
density_A
```

  - calculé à partir du graph $G$ avec la fonction`edge_density` du package `igraph`

```{r}
density_G <- edge_density(graph = G, loops = FALSE)
density_G
```

3. Calcul **Clustering Coefficient**

- pour un sommet $v$ donné

The clustering coefficient of a vertex $v$ is the ratio of total numbers of edges between the neighbors of $v$ to the maximum numbers of edges possible between these negihbors

Soit $N(v)$ l'ensemble des $k$ sommets voisins de $v$ dans un graphe $G$.

Le nombre maximum possible $k_{max}$ d'arêtes connectant les sommets de $N(v)$ est $$k_{max}=\frac{k(k-1)}{2}$$

Le **Clustering Coefficient** $CC(v)$ vaut alors $$CC(v)=\frac{2x}{k(k-1)}$$
où $x$ représente le nombre d'arêtes connectant les sommets de $N(v)$ entre eux.

- pour le graphe $G$

Le **average clustering coefficient** du graphe $G$ noté $CC(G)$ vaut alors
$$CC(G)=\frac{1}{n}\sum_{v\in V} CC(v)$$

## To have an idea about what can be done with visNetwork and shiny

```{r}
#shiny::runApp(system.file("shiny", package = "visNetwork"))

```



