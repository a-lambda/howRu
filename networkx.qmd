---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Loading graphs in Networkx

```{python}

import networkx as nx
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from networkx import bipartite

```

## Creating a graph from a list of edges

```{python}

plt.close()
G = nx.Graph()
G.add_edges_from([(0, 1), (0, 2), (0, 3), (0, 5),
                  (1, 3), (1, 6), (3, 4), (4, 5),
                  (4, 5), (4, 7), (5, 8), (8, 9)])
nx.draw_networkx(G)
plt.show()

```

## Creating a graph from loading an adjacency list file

```{python}

plt.close()
G = nx.read_adjlist('./data/G_adjlist.txt', nodetype=int)
G.edges
nx.draw_networkx(G)
plt.show()

```

## Creating a graph from an adjacency matrix

```{python}

G = nx.Graph()
G_mat = np.array([[0, 1, 1, 1, 0, 1, 0, 0, 0, 0],
                  [1, 0, 0, 1, 0, 0, 1, 0, 0, 0],
                  [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  [1, 1, 0, 0, 1, 0, 0, 0, 0, 0],
                  [0, 0, 0, 1, 0, 1, 0, 1, 0, 0],
                  [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],
                  [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                  [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]])
G_mat
G = nx.Graph(G_mat)
nx.draw_networkx(G)
plt.show()

```

## Creating a graph from and edge list file

```{python}

plt.close()
G = nx.read_edgelist('data/G_edgelist.txt', data=[('weight', int)], nodetype=int)
G.edges(data=True)
nx.draw_networkx(G)
plt.show()

```

## Creating a graph from a panda dataframe

```{python}

G_df = pd.read_csv('data/G_edgelist.txt',
                   sep='\s+',
                   header=None,
                   names=['n1', 'n2', 'weight'])
G_df                   
G = nx.from_pandas_edgelist(G_df, 'n1', 'n2', edge_attr='weight')
G.edges(data=True)
nx.draw_networkx(G)
plt.show()

```

## Chess example

```{python}

chess = nx.read_edgelist('data/chess_graph.txt', 
                         data=[('outcome', int), ('timestamp', float)],
                         create_using=nx.MultiDiGraph())
                         
chess.is_directed(), chess.is_multigraph()
chess.edges(data=True)
games_played = dict(chess.degree())
games_played
max_value = max(games_played.values())
max_key = [i for i in games_played.keys() if games_played[i] == max_value ]
print(f'player {max_key}\n{max_value} games')

```


```{python}

df = pd.DataFrame(chess.edges(data=True), columns=['white', 'black', 'outcome'])
df.head()

df['outcome'] = df['outcome'].map(lambda x: x['outcome'])
df.head()
won_as_white = df[df['outcome']==1].groupby('white').sum()
won_as_white
#won_as_black = -df[df['outcome']==-1].groupby('black').sum()
#win_count = won_as_white.add(won_as_black, fill_value=0)
#win_count.head()

```

## Coefficient de regroupement















## Mesures de distance

1. graphe exemple :

```{python}

plt.close()
G = nx.Graph()
G.add_edges_from([('A', 'B'), ('A', 'K'), ('B', 'K'), ('B', 'C'),
                  ('C', 'F'), ('F', 'G'), ('C', 'E'), ('F', 'E'),
                  ('D', 'E'), ('E', 'I'), ('E', 'H'), ('I', 'J')])
nx.draw_networkx(G)
plt.show()

```

2. bread-first search tree (arbre BFS)

```{python}

plt.close()
T = nx.bfs_tree(G, 'A')
nx.draw_networkx(T)
plt.show()
list(T.edges)

```

3. shortest path (plus court chemin)

```{python}

nx.shortest_path(G, 'A', 'H')

```

4. shortest path length (plus courte distance)

```{python}

nx.shortest_path_length(G, 'A', 'H')
nx.shortest_path_length(G, 'A')

```

5. average distance (distance moyenne)

```{python}

nx.average_shortest_path_length(G)

```

6. diamètre (diameter)

distance maximum entre 2 paires de sommets

```{python}

nx.diameter(G)

```

7. eccentricity of a node (excentricité d'un sommet)

distance la plus grande entre un sommet et tous les autres sommets

```{python}

nx.eccentricity(G)

```

8. radius of a graph (rayon d'un grahe) 

valeur de l'excentricité minimale

```{python}

nx.radius(G)

```




## Karate club network

```{python}

G = nx.karate_club_graph()
G = nx.convert_node_labels_to_integers(G, first_label=1)


```






```{r}
library(tidyverse)
chess <- read_delim("data/chess_graph.txt", col_names = c("white", "black", "outcome")) |> 
  separate_wider_delim(cols = "outcome", delim = "\t", names = c("outcome", "timestamp")) |> 
  mutate(
    timestamp = as.double(timestamp),
    outcome = as.integer(outcome)
  )

won_as_white <- chess |>
  filter(outcome == 1) |> 
  group_by(white) |> 
  summarize(somme = sum(outcome))

won_as_black <- chess |>
  filter(outcome == -1) |> 
  group_by(black) |> 
  summarize(somme = -sum(outcome))

won <- won_as_white 

```









```{python}

B = nx.Graph()
B.add_nodes_from(['A', 'B', 'C', 'D', 'E'], bipartite=0)
B.add_nodes_from([1, 2, 3, 4], bipartite=1)
B.add_edges_from([('A', 1), ('B', 1), ('C', 1), ('C', 3), ('D', 2), ('D', 3), ('E', 3), ('E', 4)])
# getting each set of nodes of a bipartite graph
bipartite.sets(B)
bipartite.is_bipartite(B)
B.add_edge('A', 'B')
bipartite.is_bipartite(B)
B.remove_edge('A', 'B')
X = set([1, 2, 3, 4])
bipartite.is_bipartite_node_set(B, X)
X = set(['A','B','C','D','E'])
bipartite.is_bipartite_node_set(B, X)

B=nx.Graph()
B.add_edges_from([('A',1), ('B',1), ('C',1), ('D',1), ('H',1),
                  ('B',2), ('C',2), ('D',2), ('E',2), ('G',2),
                  ('E',3), ('F',3), ('H',3), ('J',3), ('E',4),
                  ('I',4), ('J',4)])
X=set(['A','B','C','D','E','F','G','H','I','J'])
P=bipartite.projected_graph(B,X)
X=set([1,2,3,4])
P=bipartite.weighted_projected_graph(B,X)
nx.draw(P, with_labels=1)
plt.show()

```

